首先抛个砖，先看一下斐波那契数列：f(n) = f(n-1) + f(n-2)，于是递归型代码如下：

```Java
public int fibonacci(int n) {
    if(n == 1 || n == 2) {
        return 1;
    } else {
        return fibonacci(n-1) + fibonacci(n-2);
    }
} 
```

众所周知，递归型代码虽然简洁，但里面的重复计算非常多，时间复杂度也因此很高，如上面的代码中，求第n个数时，前面的n-2个数都会重复计算，时间复杂度为O(2^n)。

所以，动态规划就可用来解决这类问题，动态规划有两种，一种是通过map将中间结果保存起来，等第二次求的时候直接从map中获取，另一种是只保留用于推导下一个值的最小数据。

所以斐波那契数列就可以改为以下写法（实际也是循环型），对于当前值来说，只有前两个数是有用的，所以我们只需保留这两个：

```Java
public int fibonacci(int n) {
    if(n == 1 || n == 2) {
        return 1;
    }
    int pre_n = 1;
    int pre_pre_n = 1;
    int current = 0;
    for(int i = 3; i <= n; i++) {
        current = pre_n + pre_pre_n;
        pre_pre_n = pre_n;
        pre_n = current;
    }
    return current;
}
```

砖了解得差不多了，我们再引一个玉出来。

根据前面斐波那契数列的例子，我们可以总结出可以使用动态规划求解问题的特点：

1）需要求解的问题具有**相似**子问题；

2）需要求解的结果或最优结果由子问题的结果或最优结果推导出来。

求动态规划问题，一般也是有固定套路的：

1）定义**数组**或**变量**保存历史记录，避免重复计算，一般程序中都用dp[]定义，定义数组元素或变量的含义；

2）找到**数组元素之间的关系**，这一步是最关键的；

3）找到**计算的起点**以及值，起点决定终点。

下面再引几个好玉，通过几个典型的动态规划题，更深入的理解掌握动态规划：

--待续--
